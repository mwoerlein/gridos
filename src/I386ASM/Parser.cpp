/* Generated by re2c 1.0.1 on Tue Aug 21 08:08:40 2018 */
#line 1 "src/I386ASM/Parser.re"
#include "I386ASM/Parser.hpp"

#define YYMAXFILL 7

#define SIZE 50

bool Parser::freeBuffer(size_t need) {
    const size_t free = token - buffer;
    if (free < need) {
        return false;
    }
    for (char *src = token, *dest = buffer; src < limit; src++, dest++) {
        *dest = *src;
    }
    limit -= free;
    current -= free;
    token -= free;
    marker -= free;
    ctxmarker -= free;
    return true;
}

bool Parser::fillBuffer(size_t need, IStream & input)
{
    OStream & log = env().getStdO();
    if (input.empty() || !freeBuffer(need)) {
        return false;
    }
    while (!input.empty() && (limit < buffer + SIZE)) {
        input >> *limit++;
    }
    if (limit < buffer + SIZE) {
        char * maxfill = limit + YYMAXFILL;
        while (limit < maxfill) {
            *limit++ = (char) 0;
        }
    }
    return true;
};

// public
ASMInstructionList & Parser::parse(IStream & input) {
    OStream & log = env().getStdO();
    ASMInstructionList & list = env().create<ASMInstructionList>();
    
    // init parsing buffer
    MemoryInfo & bufferInfo = env().getAllocator().allocate(SIZE + YYMAXFILL);
    buffer = (char *) bufferInfo.buf;
    token = current = marker = ctxmarker = limit = buffer + SIZE;
    
    log << "parse input\n";
    
    for (;;) {
        token = current;

#line 59 "src/I386ASM/Parser.cpp"
{
	char yych;
	if ((limit - current) < 7) if (!fillBuffer(7, input)) break;
	yych = *current;
	switch (yych) {
	case '_':	goto yy4;
	default:	goto yy2;
	}
yy2:
	++current;
yy3:
#line 65 "src/I386ASM/Parser.re"
	{ log << *token; continue; }
#line 73 "src/I386ASM/Parser.cpp"
yy4:
	yych = *(marker = ++current);
	switch (yych) {
	case 'h':	goto yy5;
	case 's':	goto yy7;
	default:	goto yy3;
	}
yy5:
	yych = *++current;
	switch (yych) {
	case 'a':	goto yy8;
	default:	goto yy6;
	}
yy6:
	current = marker;
	goto yy3;
yy7:
	yych = *++current;
	switch (yych) {
	case 't':	goto yy9;
	default:	goto yy6;
	}
yy8:
	yych = *++current;
	switch (yych) {
	case 'l':	goto yy10;
	default:	goto yy6;
	}
yy9:
	yych = *++current;
	switch (yych) {
	case 'a':	goto yy11;
	default:	goto yy6;
	}
yy10:
	yych = *++current;
	switch (yych) {
	case 't':	goto yy12;
	default:	goto yy6;
	}
yy11:
	yych = *++current;
	switch (yych) {
	case 'r':	goto yy13;
	default:	goto yy6;
	}
yy12:
	yych = *++current;
	switch (yych) {
	case ':':	goto yy14;
	default:	goto yy6;
	}
yy13:
	yych = *++current;
	switch (yych) {
	case 't':	goto yy16;
	default:	goto yy6;
	}
yy14:
	++current;
#line 64 "src/I386ASM/Parser.re"
	{ log << "--halt--\n<";  for (char * cur = token; cur < current; cur++) { log << *cur; }; log << '>'; continue; }
#line 136 "src/I386ASM/Parser.cpp"
yy16:
	yych = *++current;
	switch (yych) {
	case ':':	goto yy17;
	default:	goto yy6;
	}
yy17:
	++current;
#line 63 "src/I386ASM/Parser.re"
	{ log << "--start--\n<"; for (char * cur = token; cur < current; cur++) { log << *cur; }; log << '>'; continue; }
#line 147 "src/I386ASM/Parser.cpp"
}
#line 66 "src/I386ASM/Parser.re"

    }
    
    env().destroy(bufferInfo);
    log << "parse input done\n";
    return list;
}
