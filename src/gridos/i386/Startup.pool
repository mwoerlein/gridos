/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace gridos::i386;

use gridos::i386::memory::PhysicalFreePageInfo;
use gridos::i386::memory::PhysicalPageManager;
use gridos::i386::memory::StartupRegistry;

use gridos::multiboot2::BootInformation;
use gridos::multiboot2::structs::Context;
use gridos::multiboot2::structs::MultiBootHeader;
use gridos::multiboot2::structs::MultiBootInformation;

use sys::core::utils::Bitset;
use sys::memory::Address;
use sys::memory::Allocator;
use sys::memory::MemoryInfo;
use sys::memory::MemoryIOStream;
use sys::memory::MemoryManager;
use sys::memory::MemoryRegistry;
use sys::memory::PageAllocator;
use sys::runtime::Runtime;
use sys::runtime::RuntimeBuilder;
use sys::runtime::StaticResolvedClassStorage;
use sys::stream::OStream;

class Startup extends Runtime, RuntimeBuilder {
    
    // TODO: implement and collect modules 
    int modules;
    
    // methods
    __entry__ [] blub(int magic, MultiBootInformation mbi, MultiBootHeader mbh) {
        
        // setup context
        Context context = null;
        __pasm__("subl %eax, %esp", {"%eax": Context:SIZEOF}, {"%esp": context});
        context.magic = magic;
        context.mbi = mbi;
        context.mbh = mbh;
        
        Runtime _rt = Startup:_bootstrap(Startup:CLASSNAME, 0x3000, context);
        
        // free context
        __pasm__("addl %eax, %esp", {"%eax": Context:SIZEOF});
        
        if (_rt) {
            Startup rt = _rt.cast(Startup:CLASSNAME, _rt);
            if (rt) {
                // TODO: switch to (virtual) Kernel-Stack
                // TODO: switch to dynamic loaded class and never return
                rt.initializeKernel();
            }
        }
        while (1) { __pasm__("hlt"); }
    }
    
    [Runtime] _buildRuntime(Context context) {
        Runtime bsRt := this.rt();
        CgaScreen bsScreen = bsRt.createInstance(CgaScreen:CLASSNAME);
        bsScreen.init(0xB8000);
        OStream bsOut = bsScreen.getFormattedOStream(15);
        
        if (context.magic != BootInformation:BOOTLOADER_MAGIC) {
            bsOut.printCString("Invalid magic number: ").printPtr(context.magic).printNewline();
            return null;
        }
        if (Address:from(context.mbi) % 8) {
            bsOut.printCString("Unaligned mbi: ").printAddr(context.mbi).printNewline();
            return null;
        }
        
        bsRt.setOut(bsOut);
        bsRt.setErr(bsOut);
        Allocator bsAllocator := bsRt.getAllocator();
        
        BootInformation bi = bsRt.createInstance(BootInformation:CLASSNAME);
        bi.initInfo(context.mbi, context.mbh);
        bsOut.printCString("loaded via ").printCString(bi.getBootLoader()).printNewline();
        
        // collect memory information on stack
        StartupRegistry bsSR = bsRt.createInstance(StartupRegistry:CLASSNAME);
        MemoryRegistry bsMR = bsRt.cast(MemoryRegistry:CLASSNAME, bsSR);
        bsMR.initEmptyFromAllocator(bsAllocator, 1, 100);
        bi.registerMemory(bsMR);
        
        // TODO: generate (bs)PhysicalPageManager
        // - mark mbi-page and kernel/modules as used by Kernel/Startup
        PhysicalPageManager bsPM = bsRt.createInstance(PhysicalPageManager:CLASSNAME);
        bsPM.init(bsSR.extractFreePages());
        
        int kernelStackPages = 3;
        
        // TODO: generate (bs)KernelMMU and activate paging 
        // - Identity-Map all modules/reserved, 
        // - support PageDirectory/PageTables
        // - User/Kernel-Stack/Heap
        // - remap CgaScreen
        MemoryIOStream pt000 = bsRt.createInstance(MemoryIOStream:CLASSNAME);
        {
            pt000._initBuf(bsPM.allocateZeroedPage(), PageAllocator:PAGESIZE);
            int i = 0;
            int ptr = i * PageAllocator:PAGESIZE + 1;
            pt000.seek(4 * i);
            while (i++ < 0x100) { // low mem: 0x0 - 0x100000
                pt000.printRawInt(ptr);
                ptr += PageAllocator:PAGESIZE;
            }
        }
        
        MemoryIOStream pt3c0 = bsRt.createInstance(MemoryIOStream:CLASSNAME);
        {
            pt3c0._initBuf(bsPM.allocateZeroedPage(), PageAllocator:PAGESIZE);
            PhysicalFreePageInfo ksPages = bsPM.allocatePhysicalPages(kernelStackPages);
            int i = kernelStackPages;
            int ptr = Address:from(ksPages.self) + 1;
            while (i-- > 0) { // kernel stack mem: 0xF0000000 - 0xF000X000
                pt3c0.printRawInt(ptr);
                ptr += PageAllocator:PAGESIZE;
            }
        }
        MemoryIOStream pt3fe = bsRt.createInstance(MemoryIOStream:CLASSNAME);
        {
            pt3fe._initBuf(bsPM.allocateZeroedPage(), PageAllocator:PAGESIZE);
            
            pt3fe.seek(4 * 0x3ff);
            pt3fe.printRawInt(Bitset:and(0xB8000, 0xfffff000) + 1);
        }
        
        MemoryIOStream kernelPD = bsRt.createInstance(MemoryIOStream:CLASSNAME);
        {
            kernelPD._initBuf(bsPM.allocateZeroedPage(), PageAllocator:PAGESIZE);
            
            kernelPD.seek(4 * 0x0);
            kernelPD.printRawInt(Bitset:and(pt000.startAddr(), 0xfffff000) + 1);
            
            kernelPD.seek(4 * 0x3c0);
            kernelPD.printRawInt(Bitset:and(pt3c0.startAddr(), 0xfffff000) + 1);
            
            kernelPD.seek(4 * 0x3fe);
            kernelPD.printRawInt(Bitset:and(pt3fe.startAddr(), 0xfffff000) + 1);
            
            kernelPD.seek(4 * 0x3ff);
            kernelPD.printRawInt(Bitset:and(kernelPD.startAddr(), 0xfffff000) + 1);
        }
        
        // enable paging
        __pasm__(<"
             .byte 0x0F; .byte 0x22; .byte 0xD8 #//movl %eax, %cr3 
             .byte 0x0F; .byte 0x20; .byte 0xC0 #//movl %cr0, %eax
             orl 0x80000001, %eax 
             .byte 0x0F; .byte 0x22; .byte 0xC0 #//movl %eax, %cr0
        ">, {"%eax": kernelPD.startAddr()});
        
        // initialize kernel heap
        MemoryManager bsMM = bsRt.createInstance(MemoryManager:CLASSNAME);
        MemoryInfo available = Address:cast(0xF0000000);
        available.buf = 0xF0000000;
        available.len = kernelStackPages * PageAllocator:PAGESIZE;
        available.flags = MemoryInfo:FLAGS_AVAILABLE;
        bsMM.initEmpty(available, 1, 0);
        
        // create "heap"-based runtime
        bsRt.setAllocator(bsMM.allocator());
        Startup rt = bsRt.createInstance(Startup:CLASSNAME);
        bsRt.setAllocator(bsAllocator);
        rt.setRt(rt.runtime());
        rt.setAllocator(bsMM.allocator());
        rt.setClassStorage(bsRt.getClassStorage());
        
        // create "heap"-based memory management
        MemoryManager mm = rt.createInstance(MemoryManager:CLASSNAME);
        mm.initFromMemoryManager(bsMM);
        rt.setAllocator(mm.allocator());
        
        // TODO: initialize DynamicClassStorage with copies of static classes
        // create "heap"-based class storage
        StaticResolvedClassStorage crcs = rt.createInstance(StaticResolvedClassStorage:CLASSNAME);
        rt.setClassStorage(crcs.classStorage());
        crcs.rebuildClasses();
        
        // create "heap"-based stdOut
        CgaScreen screen = rt.createInstance(CgaScreen:CLASSNAME);
        screen.init(0xFFBFF000);
        rt.setOut(screen.getFormattedOStream(7));
        rt.setErr(screen.getFormattedOStream(12));
        
        // TODO: create "heap"-based module-descriptions
        bsRt.setOut(rt.out());
        bsRt.setErr(rt.err());
        bi.registerModules();
        
        // cleanup
        bsMR.destroy();
        bsMM.destroy();
        bi.destroy();
        bsOut.destroy();
        bsScreen.destroy();
        
        // TODO: free mbi-page
        return rt.runtime();
    }
    
    [] initializeKernel() {
        // TODO: analyse modules
        // - remap/copy GIDT into Kernel-Space and initiate idt/gdt
        // - remap/copy store into Kernel-Space and register at DynamicClassManager
        // - free startup-pages and copied module-pages to free low memory
        
        sys::memory::Address:storeAddress(
            0xFFC00000 + Bitset:lshift(0x3fe, 12) + Bitset:lshift(0x3fd, 2),
            Bitset:and(0x10000, 0xfffff000) + 1
        ); 
        sys::memory::Address:storeAddress(
            0xFFC00000 + Bitset:lshift(0x3fe, 12) + Bitset:lshift(0x3fe, 2),
            Bitset:and(0x11000, 0xfffff000) + 1
        ); 

/*        
        // flush paging
        __pasm__(<"
             .byte 0x0F; .byte 0x20; .byte 0xD8 #//movl %cr3, %eax 
             .byte 0x0F; .byte 0x22; .byte 0xD8 #//movl %eax, %cr3
        ">); 
*/
        InterruptVectorTable ivt = this.createInstance(InterruptVectorTable:CLASSNAME);
        ivt._init(Address:cast(0xFFBFE000));

        /* reset coprocessors */        
        IOPort:outb(0xf0, 0); //delay();
        IOPort:outb(0xf1, 0); //delay();
        
        /* activate keyboard and interrupts */
        PIC pic = this.createInstance(PIC:CLASSNAME);
        Keyboard kbd = this.createInstance(Keyboard:CLASSNAME);
        kbd.plugin(pic, ivt);
        ivt.activate();
        
        // TODO: create and initialize kernel runtime
        this.err().printCString("Initialize kernel").printNewline();
        // TODO: run kernel thread and free/destroy startup memory/objects
        this.createAndRunThread(gridos::KernelThread:CLASSNAME);
    }
}
