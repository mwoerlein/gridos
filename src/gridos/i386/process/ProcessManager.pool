/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace gridos::i386::process;

use gridos::i386::memory::MMU;
use sys::memory::Address;
use sys::memory::PageAllocator;

class ProcessManager extends sys::core::Object {

    Thread currentThread;
    Thread first;
    Thread last;
    int pidCounter;
    MMU mmu;
    
    [Thread] init(MMU mmu) {
        this.mmu = mmu;
        Thread t = this._newThread(mmu.getActiveDirectory());
        t.setNext(t);
        return first = last = currentThread = t;
    }
    
    [] switchToNext(sys::stream::OStream debug) {
        debug.printCString("switch from ").printInt(currentThread.getPid())
            .printCString(" to ").printInt(currentThread.getNext().getPid()).printNewline();
        this.switchTo(currentThread.getNext());
        debug.printCString("back in ").printInt(currentThread.getPid()).printNewline();
    }
    
    [] switchTo(Thread nextThread) {
        //Save previous thread's state
        //Notes:
        //  For cdecl; EAX, EBX, and EDX are already saved by the caller and don't need to be saved again
        //  EIP is already saved on the stack by the caller's "CALL" instruction
        //  The task isn't able to change CR3 so it doesn't need to be saved
        //  Segment registers are constants (while running kernel code) so they don't need to be saved
        /* 
        //Not yet required without register allocation. pushad/popad already stores everything into stack frame 
        __pasm__(<"
            pushl %ecx
            pushl %esi
            pushl %edi
        ">);
        */
        
        // Save EBP/ESP for previous thread's kernel stack
        int esp = 0;
        __pasm__(<"
            pushl %ebp
        ">, {}, {"%esp": esp});
        currentThread.setTopOfStack(esp);
        currentThread = nextThread;
        // switch stack pointer/base pointer and page directory at once
        __pasm__(<"
            movl %ebx, %esp
            movl %cr3, %ebx         #// ebx = previous task's virtual address space
            cmpl %eax, %ebx         #// Does the virtual address space need to being changed?
            je _pm_switch_done_vas  #// no, virtual address space is the same, so don't reload it and cause TLB flushes
            movl %eax, %cr3         #// yes, load the next task's virtual address space
        _pm_switch_done_vas:
            popl %ebp
        ">, {"%eax": nextThread.getPageDirectoryPAddr(), "%ebx": nextThread.getTopOfStack()}, {"%ebx": null});
        mmu.refreshActiveDirectory();
        
        //Restore next task's state
        /*
        //Not yet required without register allocation. pushad/popad already stores everything into stack frame
        __pasm__(<"
            popl %edi
            popl %esi
            popl %ecx
        ">);
        */
    }
    
    [Process] createProcess(cstring taskClassname) {
        int setup_entry = 0;
        __pasm__("movl 8(%ebp), %eax; addl _cr_mo_setup_entry, %eax", {}, {"%eax": setup_entry});
        
        [int pageDirectoryPAddr, int mappedStack] = mmu.newThreadPageDirectoryAndKernelStack();
        Thread thread = this._newThread(pageDirectoryPAddr);

        int tos = mappedStack + PageAllocator:PAGESIZE;
        int ebpBase = 0xF0000000 - tos;
        
        // fake stack frame of called _setup_entry
        Address:storeString(tos-=4, taskClassname); // argument
        Address:store(tos-=4, this);
        Address:store(tos-=4, this.getClass().getDesc());
        Address:storeAddress(tos-=4, 0x0); // %eip
        Address:storeAddress(tos-=4, 0xF0000000); // %ebp
        int ebpSetup = ebpBase + tos;
        
        // fake stack frame with _setup_entry as caller of switchTo 
        Address:store(tos-=4, thread);
        Address:store(tos-=4, this);
        Address:store(tos-=4, this.getClass().getDesc());
        Address:storeAddress(tos-=4, setup_entry); // %eip
        Address:storeAddress(tos-=4, ebpSetup); // %ebp
        int ebpSwitch = ebpBase + tos;
        // local/temporal variables of switchTo
        tos-=0x18;
        // pushad 
        Address:storeAddress(tos-=4, 0x0); // %eax
        Address:storeAddress(tos-=4, 0x0); // %ecx
        Address:storeAddress(tos-=4, 0x0); // %edx
        Address:storeAddress(tos-=4, 0x0); // %ebx
        Address:storeAddress(tos-=4, 0x0); // %esp
        Address:storeAddress(tos-=4, ebpSwitch); // %ebp
        Address:storeAddress(tos-=4, 0x0); // %esi
        Address:storeAddress(tos-=4, 0x0); // %edi
        // stored task state
        /*
        //Not yet required without register allocation. pushad/popad already stores everything into stack frame
        Address:storeAddress(tos-=4, 0); // %ecx
        Address:storeAddress(tos-=4, 0); // %esi
        Address:storeAddress(tos-=4, 0); // %edi
        */
        Address:storeAddress(tos-=4, ebpSwitch); // %ebp
        
        mmu.unmap(mappedStack);
        
        thread.setTopOfStack(ebpBase + tos).setNext(first);
        last.setNext(thread);
        last = thread;
        return thread.getProcess();
    }
    
    [] _setup_entry(cstring taskClassname) {
        __pasm__(<"
            _cr_mo_setup_entry := (_setup_entry - _gridos_i386_process_ProcessManager)
            _setup_entry:
        ">);
        this._setupNewThread(taskClassname);
    }
    
    [] _setupNewThread(cstring taskClassname) {
        this.rt().err()
            .printCString("setup new thread in process ").printInt(currentThread.getPid())
            .printCString(" for class '").printCString(taskClassname).printChar('\'')
            //.printCString(" via ").print(this)
            .printNewline();
        // TODO: setup ProcessRuntime, create and run thread/task (in userland), and cleanup/exit process/thread if task returns 
        this.rt().createAndRunTask(taskClassname);
        while (1) { __pasm__("hlt"); }
    }
    
    [Thread] _newThread(int pageDirectoryPAddr) {
        Process p = this.rt().createInstance(Process:CLASSNAME);
        return p.setPid(++pidCounter).setPageDirectoryPAddr(pageDirectoryPAddr)._newThread();
    }
    
}
