/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace gridos::i386::process;

use gridos::i386::memory::MMU;
use gridos::i386::memory::MMUPageAllocator;
use gridos::i386::memory::StackBuilder;

use gridos::i386::sys::OutStream;
use gridos::i386::sys::ErrStream;
use gridos::i386::sys::Clock;
use gridos::i386::sys::PageAllocator;

use sys::memory::PagedMemoryManager;
use sys::runtime::Runtime;
use sys::stream::OStream;

class ProcessManager extends sys::core::Object {

    MMU mmu;
    Scheduler scheduler;
    
    Process first;
    Process last;
    int pidCounter;
    
    [ProcessManager] init(Scheduler scheduler, MMU mmu) {
        this.scheduler = scheduler;
        this.mmu = mmu;
        Runtime rt = this.rt();
        Process p = this._newProcess(rt, mmu.getActiveDirectory(), rt.out(), rt.err());
        scheduler.setInitialThread(p._newThread());
        return this;
    }
    
    [Process] createProcess(cstring taskClassname, OStream out, OStream err) {
        [int pageDirectoryPAddr, StackBuilder sb] = mmu.newThreadPageDirectoryAndKernelStack(MMU:AFTER_KERNEL_LOCAL_STACKS);
        Runtime rt = this.rt().cloneRuntime(); rt.setOut(out); rt.setErr(err);
        Process process := this._newProcess(rt, pageDirectoryPAddr, out, err);
        scheduler.addReadyThread(this.setupThread(process._newThread(), sb, taskClassname));
        sb.unmap(mmu);
        sb.destroy();
        return process;
    }

    // must be called with active process page directory but still in kernel mode!     
    [Runtime] initProcess(Process process) {
        Runtime ksRt := process.rt();
        // bootstrap kernel runtime for new process
        MMUPageAllocator tmpKernelMPA = ksRt.createInstance(MMUPageAllocator:CLASSNAME);
        tmpKernelMPA._init(mmu, MMU:START_KERNEL_LOCAL_HEAP);
        PagedMemoryManager tmpKernelPMM = ksRt.createInstance(PagedMemoryManager:CLASSNAME);
        tmpKernelPMM.setMinimalPageAllocation(1).initFromPageAllocator(tmpKernelMPA.pageAllocator(), 1);
        // TODO: which class should be used for kernel runtime?
        Runtime kernelRt = ksRt.createInstanceAt(Runtime:CLASSNAME, tmpKernelPMM.allocator());
        {
            // use shared classes and clock
            kernelRt.setClassStorage(ksRt.getClassStorage());
            kernelRt.setClock(ksRt.getClock());
            // TODO: use process out/err
            kernelRt.setOut(ksRt.out()); 
            kernelRt.setErr(ksRt.err());
            kernelRt.setAllocator(tmpKernelPMM.allocator());
            
            // recreate allocator within kernel local runtime
            MMUPageAllocator kernelMPA = kernelRt.createInstance(MMUPageAllocator:CLASSNAME);
            PagedMemoryManager kernelPMM = kernelRt.createInstance(PagedMemoryManager:CLASSNAME);
            // get top of heap *after* creating instances on heap via temporary page allocator
            kernelMPA._init(mmu, tmpKernelMPA.getTopOfHeap());
            kernelPMM.initFromPagedMemoryManager(kernelMPA.pageAllocator(), tmpKernelPMM);
            kernelPMM.setMinimalPageAllocation(1).initFromPageAllocator(tmpKernelMPA.pageAllocator(), 1);
            kernelRt.setAllocator(kernelPMM.allocator());
        }
        tmpKernelPMM.destroy();
        tmpKernelMPA.destroy();
        
        // bootstrap user runtime for new process
        MMUPageAllocator userMPA = kernelRt.createInstance(MMUPageAllocator:CLASSNAME);
        userMPA._init(mmu, MMU:START_USER_HEAP);
        PagedMemoryManager tmpUserPMM = ksRt.createInstance(PagedMemoryManager:CLASSNAME);
        // TODO: adjust user page allocation to increase performance 
        tmpUserPMM.setMinimalPageAllocation(1).initFromPageAllocator(userMPA.pageAllocator(), 1);
        Runtime userRt = kernelRt.createInstanceAt(Runtime:CLASSNAME, tmpUserPMM.allocator());
        {
            userRt.setAllocator(tmpUserPMM.allocator());
            // TODO: setup user class storage and refresh instances
            userRt.setClassStorage(kernelRt.getClassStorage());
            // temporary use of kernel instances until correct ones are generated
            userRt.setClock(kernelRt.getClock());
            userRt.setOut(kernelRt.out()); 
            userRt.setErr(kernelRt.err());
            
            // create/use syscall instances
            OutStream out = userRt.createInstance(OutStream:CLASSNAME);
            ErrStream err = userRt.createInstance(ErrStream:CLASSNAME);
            Clock clock = userRt.createInstance(Clock:CLASSNAME);
            PageAllocator pa = userRt.createInstance(PageAllocator:CLASSNAME);
            PagedMemoryManager pmm = userRt.createInstance(PagedMemoryManager:CLASSNAME);
            pmm.initFromPagedMemoryManager(pa.pageAllocator(), tmpUserPMM);
            
            userRt.setOut(out.ostream());
            userRt.setErr(err.ostream());
            userRt.setClock(clock.clock());
            userRt.setAllocator(pmm.allocator());
        }
        tmpUserPMM.destroy();
        // setup process        
        process.setRuntimes(kernelRt, userRt, userMPA.pageAllocator());
        return userRt;
    }
    
    [Process] _newProcess(Runtime rt, int pageDirectoryPAddr, OStream out, OStream err) {
        Process p = rt.createInstance(Process:CLASSNAME);
        if (last) {
            p.setNext(first);
            last.setNext(p);
            last = p;
        } else {
            first = last = p.setNext(p);
        }
        return p.init(++pidCounter, pageDirectoryPAddr, out, err);
    }
    
    [Thread] setupThread(Thread thread, StackBuilder sb, cstring taskClassname) {
        int setup_entry = 0;
        __pasm__("movl 8(%ebp), %eax; addl _cr_mo_setup_entry, %eax", {}, {"%eax": setup_entry});
        
        { // fake stack frame for _setupEntry
            int basePtr = sb.getTopOfStack();
            sb.pushString(taskClassname);   // second argument
            sb.pushPtr(thread);             // first argument
            sb.buildMethodCallEntry(this, this.getClass(), 0, basePtr);
        }
        scheduler.setupStackFrameForSwitchTo(sb, setup_entry, thread);
        
        thread.setTopOfStack(sb.getTopOfStack());
        return thread;
    }
    
    [] _setupEntry(Thread thread, cstring taskClassname) {
        __pasm__(<"
            _cr_mo_setup_entry := (_setup_entry - _gridos_i386_process_ProcessManager)
            _setup_entry:
        ">);
        this._setupNewThread(thread, taskClassname);
    }
    
    [] _setupNewThread(Thread thread, cstring taskClassname) {
        this.rt().err()
            .printCString("setup new thread in process ").printInt(thread.getPid())
            .printCString(" for class '").printCString(taskClassname).printChar('\'')
            //.printCString(" via ").print(this)
            .printNewline();
        
        Runtime userRt := this.initProcess(thread.getKernelProcess());
        // TODO: init/prepare user thread stack
        
        // TODO: switch to user mode and user thread stack
        userRt.createAndRunTask(taskClassname);
        // TODO: cleanup/exit process/thread if task returns
        //scheduler.terminateThread(thread);
        while (1) {
            userRt.yield();
            userRt.sleep(5,0); // wait some time
        }
    }
    
}
