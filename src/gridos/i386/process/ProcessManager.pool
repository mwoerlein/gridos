/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace gridos::i386::process;

use gridos::i386::memory::MMU;
use gridos::i386::memory::StackBuilder;

use gridos::i386::syscall::OutStream;
use gridos::i386::syscall::ErrStream;
use gridos::i386::syscall::Clock;
use gridos::i386::syscall::PageAllocator;

use sys::memory::PagedMemoryManager;
use sys::runtime::Runtime;
use sys::stream::OStream;

class ProcessManager extends sys::core::Object {

    MMU mmu;
    Scheduler scheduler;
    
    Process first;
    Process last;
    int pidCounter;
    
    [ProcessManager] init(Scheduler scheduler, MMU mmu) {
        this.scheduler = scheduler;
        this.mmu = mmu;
        Runtime rt = this.rt();
        Process p = this._newProcess(rt, mmu.getActiveDirectory(), rt.out(), rt.err());
        scheduler.setInitialThread(p._newThread());
        return this;
    }
    
    [Process] createProcess(cstring taskClassname, OStream out, OStream err) {
        [int pageDirectoryPAddr, StackBuilder sb] = mmu.newThreadPageDirectoryAndKernelStack(0xF0000000);
        Runtime rt = this.rt().cloneRuntime(); rt.setOut(out); rt.setErr(err);
        Process process := this._newProcess(rt, pageDirectoryPAddr, out, err);
        scheduler.addReadyThread(this.setupThread(process._newThread(), sb, taskClassname));
        sb.unmap(mmu);
        sb.destroy();
        return process;
    }
    
    [Process] _newProcess(Runtime rt, int pageDirectoryPAddr, OStream out, OStream err) {
        Process p = rt.createInstance(Process:CLASSNAME);
        if (last) {
            p.setNext(first);
            last.setNext(p);
            last = p;
        } else {
            first = last = p.setNext(p);
        }
        return p.init(++pidCounter, pageDirectoryPAddr, out, err);
    }
    
    [Thread] setupThread(Thread thread, StackBuilder sb, cstring taskClassname) {
        int setup_entry = 0;
        __pasm__("movl 8(%ebp), %eax; addl _cr_mo_setup_entry, %eax", {}, {"%eax": setup_entry});
        
        { // fake stack frame for _setupEntry
            int basePtr = sb.getTopOfStack();
            sb.pushString(taskClassname);   // second argument
            sb.pushPtr(thread);             // first argument
            sb.buildMethodCallEntry(this, this.getClass(), 0, basePtr);
        }
        scheduler.setupStackFrameForSwitchTo(sb, setup_entry, thread);
        
        thread.setTopOfStack(sb.getTopOfStack());
        return thread;
    }
    
    [] _setupEntry(Thread thread, cstring taskClassname) {
        __pasm__(<"
            _cr_mo_setup_entry := (_setup_entry - _gridos_i386_process_ProcessManager)
            _setup_entry:
        ">);
        this._setupNewThread(thread, taskClassname);
    }
    
    [] _setupNewThread(Thread thread, cstring taskClassname) {
        this.rt().err()
            .printCString("setup new thread in process ").printInt(thread.getPid())
            .printCString(" for class '").printCString(taskClassname).printChar('\'')
            //.printCString(" via ").print(this)
            .printNewline();
        //*
        Runtime trt = thread.rt();
        OutStream out = trt.createInstance(OutStream:CLASSNAME);
        ErrStream err = trt.createInstance(ErrStream:CLASSNAME);
        PageAllocator pa = trt.createInstance(PageAllocator:CLASSNAME);
        Clock clock = trt.createInstance(Clock:CLASSNAME);
        trt.setOut(out.ostream());
        trt.setErr(err.ostream());
        //trt.setClock(clock.clock());
        
        PagedMemoryManager ppm = trt.createInstance(PagedMemoryManager:CLASSNAME);
        ppm.initFromPageAllocator(pa.pageAllocator(), 1);
        trt.setAllocator(ppm.allocator());
        
        //*/
        // TODO: setup ProcessRuntime, create and run thread/task (in userland), and cleanup/exit process/thread if task returns 
        thread.rt().createAndRunTask(taskClassname);
        while (1) { __pasm__("hlt"); }
    }
    
}
