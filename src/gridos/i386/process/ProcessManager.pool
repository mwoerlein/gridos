/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace gridos::i386::process;

use gridos::i386::GlobalDescriptorTable;

use gridos::i386::memory::MMU;
use gridos::i386::memory::MMUPageAllocator;
use gridos::i386::memory::StackBuilder;

use gridos::i386::sys::OutStream;
use gridos::i386::sys::ErrStream;
use gridos::i386::sys::Clock;
use gridos::i386::sys::PageAllocator;

use sys::memory::PagedMemoryManager;
use sys::runtime::Runtime;
use sys::stream::OStream;

class ProcessManager extends sys::core::Object {

    MMU mmu;
    Scheduler scheduler;
    GlobalDescriptorTable gdt;
    
    Process first;
    Process last;
    int pidCounter;
    
    [ProcessManager] init(Scheduler scheduler, MMU mmu, GlobalDescriptorTable gdt) {
        this.gdt = gdt;
        this.scheduler = scheduler;
        this.mmu = mmu;
        // setup initial kernel process/thread
        Runtime rt = this.rt();
        Process process = this._newProcess(mmu.getActiveDirectory());
        Thread thread = process.createOwn(Thread:CLASSNAME);
        thread._initStart(process);
        process._initFinish(rt, rt, null);
        thread._initFinish();
        scheduler.setInitialThread(thread);
        return this;
    }
    
    [Process] createProcess(cstring taskClassname, OStream out, OStream err) {
        [int pageDirectoryPAddr, StackBuilder sb] = mmu.newThreadPageDirectoryAndKernelStack(MMU:AFTER_KERNEL_LOCAL_STACKS);
        
        Process process := this._newProcess(pageDirectoryPAddr);
        Thread thread := this.setupNewProcess(process, sb, taskClassname, out, err);
        
        scheduler.addReadyThread(thread);
        sb.unmap(mmu);
        sb.destroy();
        return process;
    }
    
    [Process] _newProcess(int pageDirectoryPAddr) {
        Process p = this.rt().createInstance(Process:CLASSNAME);
        if (last) {
            p.setNext(first);
            last.setNext(p);
            last = p;
        } else {
            first = last = p.setNext(p);
        }
        return p._initStart(++pidCounter, pageDirectoryPAddr);
    }
    
    [Thread] setupNewProcess(Process process, StackBuilder sb, cstring taskClassname, OStream out, OStream err) {
        Thread thread = process.createOwn(Thread:CLASSNAME);
        thread._initStart(process);
        
        { // fake stack frame for __setupProcess
            int basePtr = sb.getTopOfStack();
            sb.pushPtr(err);                // fifth argument
            sb.pushPtr(out);                // forth argument
            sb.pushString(taskClassname);   // third argument
            sb.pushPtr(thread);             // second argument
            sb.pushPtr(process);            // first argument
            sb.buildMethodCallEntry(this, this.getClass(), 0, basePtr);
        }
        scheduler.setupStackFrameForSwitchTo(sb, this.__getSetupProcessEntry(), thread);
        
        thread.setTopOfStack(sb.getTopOfStack());
        return thread;
    }
    
    [Thread] setupNewThread(Thread thread, StackBuilder sb, cstring taskClassname) {
        { // fake stack frame for __setupThread
            int basePtr = sb.getTopOfStack();
            sb.pushString(taskClassname);   // second argument
            sb.pushPtr(thread);             // first argument
            sb.buildMethodCallEntry(this, this.getClass(), 0, basePtr);
        }
        scheduler.setupStackFrameForSwitchTo(sb, this.__getSetupThreadEntry(), thread);
        
        thread.setTopOfStack(sb.getTopOfStack());
        return thread;
    }
    
    [int] __getSetupProcessEntry() {
        int entry = 0;
        __pasm__("movl 8(%ebp), %eax; addl _cr_mo_setup_process_entry, %eax", {}, {"%eax": entry});
        return entry;
    }
    
    [] __setupProcess(Process process, Thread thread, cstring taskClassname, OStream out, OStream err) {
        __pasm__("_cr_mo_setup_process_entry := (_setup_process_entry - _gridos_i386_process_ProcessManager); _setup_process_entry:");
        this._setupProcess(process, out, err);
        this._setupThread(thread, taskClassname);
    }

    [int] __getSetupThreadEntry() {
        int entry = 0;
        __pasm__("movl 8(%ebp), %eax; addl _cr_mo_setup_thread_entry, %eax", {}, {"%eax": entry});
        return entry;
    }
    
    [] __setupThread(Thread thread, cstring taskClassname) {
        __pasm__(<"
            _cr_mo_setup_thread_entry := (_setup_thread_entry - _gridos_i386_process_ProcessManager)
            _setup_thread_entry:
        ">);
        this._setupThread(thread, taskClassname);
    }
    
    [] _setupProcess(Process process, OStream out, OStream err) {
        this.rt().err()
            .printCString("setup new process ").printInt(process.getPid())
            .printCString(" via ").print(this)
            .print(out).print(err)
            .printNewline();
        
        Runtime ksRt := process.rt();
        // bootstrap kernel runtime for new process
        MMUPageAllocator tmpKernelMPA = ksRt.createInstance(MMUPageAllocator:CLASSNAME);
        tmpKernelMPA._init(mmu, MMU:START_KERNEL_LOCAL_HEAP);
        PagedMemoryManager tmpKernelPMM = ksRt.createInstance(PagedMemoryManager:CLASSNAME);
        tmpKernelPMM.setMinimalPageAllocation(1).initFromPageAllocator(tmpKernelMPA.pageAllocator(), 1);
        // TODO: which class should be used for kernel runtime?
        Runtime kernelRt = ksRt.createInstanceAt(Runtime:CLASSNAME, tmpKernelPMM.allocator());
        {
            // use shared classes and clock
            kernelRt.setClassStorage(ksRt.getClassStorage());
            kernelRt.setClock(ksRt.getClock());
            kernelRt.setOut(out); 
            kernelRt.setErr(err);
            kernelRt.setAllocator(tmpKernelPMM.allocator());
            
            // recreate allocator within kernel local runtime
            MMUPageAllocator kernelMPA = kernelRt.createInstance(MMUPageAllocator:CLASSNAME);
            PagedMemoryManager kernelPMM = kernelRt.createInstance(PagedMemoryManager:CLASSNAME);
            // get top of heap *after* creating instances on heap via temporary page allocator
            kernelMPA._init(mmu, tmpKernelMPA.getTopOfHeap());
            kernelPMM.initFromPagedMemoryManager(kernelMPA.pageAllocator(), tmpKernelPMM);
            kernelPMM.setMinimalPageAllocation(10).initFromPageAllocator(tmpKernelMPA.pageAllocator(), 1);
            kernelRt.setAllocator(kernelPMM.allocator());
        }
        tmpKernelPMM.destroy();
        tmpKernelMPA.destroy();
        
        // bootstrap user runtime for new process
        MMUPageAllocator userMPA = kernelRt.createInstance(MMUPageAllocator:CLASSNAME);
        userMPA._init(mmu, MMU:START_USER_HEAP);
        PagedMemoryManager tmpUserPMM = ksRt.createInstance(PagedMemoryManager:CLASSNAME);
        // TODO: adjust user page allocation to increase performance 
        tmpUserPMM.setMinimalPageAllocation(1).initFromPageAllocator(userMPA.pageAllocator(), 1);
        Runtime userRt = kernelRt.createInstanceAt(Runtime:CLASSNAME, tmpUserPMM.allocator());
        {
            userRt.setAllocator(tmpUserPMM.allocator());
            // TODO: setup user class storage and refresh instances
            userRt.setClassStorage(kernelRt.getClassStorage());
            // temporary use of kernel instances until correct ones are generated
            userRt.setClock(kernelRt.getClock());
            userRt.setOut(kernelRt.out()); 
            userRt.setErr(kernelRt.err());
            
            // create/use syscall instances
            OutStream out = userRt.createInstance(OutStream:CLASSNAME);
            ErrStream err = userRt.createInstance(ErrStream:CLASSNAME);
            Clock clock = userRt.createInstance(Clock:CLASSNAME);
            PageAllocator pa = userRt.createInstance(PageAllocator:CLASSNAME);
            PagedMemoryManager pmm = userRt.createInstance(PagedMemoryManager:CLASSNAME);
            pmm.initFromPagedMemoryManager(pa.pageAllocator(), tmpUserPMM);
            
            userRt.setOut(out.ostream());
            userRt.setErr(err.ostream());
            userRt.setClock(clock.clock());
            userRt.setAllocator(pmm.allocator());
        }
        tmpUserPMM.destroy();
        // setup process        
        process._initFinish(kernelRt, userRt, userMPA.pageAllocator());
    }
    
    [] _setupThread(Thread thread, cstring taskClassname) {
        this.rt().err()
            .printCString("setup new thread in process ").printInt(thread.getPid())
            .printCString(" for class '").printCString(taskClassname).printChar('\'')
            //.printCString(" via ").print(this)
            .printNewline();
        
        thread._initFinish();
        
        {
            // prepare user thread stack
            int userTopOfStack = MMU:AFTER_USER_STACKS; // TODO #30: determine correct stack
            mmu.allocateStackPagesAt(userTopOfStack, 1);
            // switch to user thread stack and store kernel thread stack for syscall entries
            __pasm__("movl %eax, %esp", {"%eax": userTopOfStack});
            // switch to user mode
            gdt.toUserMode();
        }
        {
            // create and run task in userland
            Runtime userRt := thread.getKernelProcess().getUserRuntime();
            userRt.createAndRunTask(taskClassname);
            
            // there is no way back to kernel mode => never return!
            // TODO: cleanup/exit process/thread if task returns
            //scheduler.terminateThread(thread);
            while (1) {
                userRt.yield();
                userRt.sleep(5,0); // wait some time
            }
        }
    }
    
}
