/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace gridos::multiboot2;

use gridos::multiboot2::structs::HeaderTagAddress;
use gridos::multiboot2::structs::MMapEntry;
use gridos::multiboot2::structs::Tag;
use gridos::multiboot2::structs::TagBasicMemInfo;
use gridos::multiboot2::structs::TagMMap;
use gridos::multiboot2::structs::TagModule;
use gridos::multiboot2::structs::TagString;

use sys::core::Object;
use sys::core::OStream;
use sys::memory::MemoryRegistry;

class BootInformation extends Object {
    
    int BOOTLOADER_MAGIC := 0x36d76289;
    
    int mbi;
    int mbh;
    
    HeaderTagAddress address;
    TagString commandline;
    TagString bootloader;
    TagBasicMemInfo meminfo;
    TagMMap mmap;
    TagModuleListElement modules;
    
    [] initInfo(int mbi, int mbh) {
        OStream out = this.rt().out();
        this.mbi = mbi;
        this.mbh = mbh;
        this.address = null;
        this.commandline = null;
        this.bootloader = null;
        this.meminfo = null;
        this.mmap = null;
        this.modules = null;
        
        Tag tag = null;
        __pasm__("addl %ebx, %eax", {"%eax": mbi, "%ebx": 8}, {"%eax": tag});
        while (tag.type != Tag:TYPE_END) {
            int type = tag.type;
            if (type == Tag:TYPE_CMDLINE) {
                __pasm__("", {"%eax": tag}, {"%eax": this.commandline});
            } else if (type == Tag:TYPE_BOOT_LOADER_NAME) {
                __pasm__("", {"%eax": tag}, {"%eax": this.bootloader});
            } else if (type == Tag:TYPE_MODULE) {
                TagModule module = null;
                __pasm__("", {"%eax": tag}, {"%eax": module});
                TagModuleListElement newElem = this.rt().createInstance(TagModuleListElement:CLASSNAME);
                newElem.setModule(module);
                newElem.setNext(this.modules);
                this.modules = newElem;
            } else if (type == Tag:TYPE_BASIC_MEMINFO) {
                __pasm__("", {"%eax": tag}, {"%eax": this.meminfo});
            } else if (type == Tag:TYPE_MMAP) {
                __pasm__("", {"%eax": tag}, {"%eax": this.mmap});
            }
            __pasm__("addl %ebx, %eax", {"%eax": tag, "%ebx": ((tag.size + 7) / 8) * 8}, {"%eax": tag});
        }
        
        __pasm__("addl %ebx, %eax", {"%eax": mbh, "%ebx": 16}, {"%eax": tag});
        while (tag.type != Tag:TYPE_END) {
            int type = tag.type % 256;
            if (type == Tag:HEADER_ADDRESS) {
                __pasm__("", {"%eax": tag}, {"%eax": this.address});
            }
            __pasm__("addl %ebx, %eax", {"%eax": tag, "%ebx": ((tag.size + 7) / 8) * 8}, {"%eax": tag});
        }
    }
    
    [cstring] getBootLoader() {
        return this._getTagStringValue(bootloader);
    }
    
    [cstring] getCommandLine() {
        return this._getTagStringValue(commandline);
    }
    
    [] registerMemory(MemoryRegistry registry) {
        OStream out = this.rt().out();
        int curAddr = 0;
        int endAddr = 0;
        
        __pasm__("addl %ebx, %eax", {"%eax": mmap, "%ebx": TagMMap:SIZEOF}, {"%eax": curAddr});
        __pasm__("addl %ebx, %eax", {"%eax": mmap, "%ebx": mmap.size}, {"%eax": endAddr});
        while (curAddr < endAddr) {
            MMapEntry entry = null;
            __pasm__("", {"%eax": curAddr}, {"%eax": entry});
            if (entry.addr_high || entry.len_high) {
                // ignore memory > 4GB, 64 bit not yet available
                out.printCString(" ignore highmem @")
                    .printPtr(entry.addr_high).printChar(':').printPtr(entry.addr)
                   .printCString(" of len ")
                    .printPtr(entry.len_high).printChar(':').printPtr(entry.len)
                    .printNewline();
            } else if (entry.type == MMapEntry:TYPE_AVAILABLE) {
                if (this._overflow(entry.addr, entry.len)) {
                    registry.registerAvailableMemory(entry.addr, 0xffffffff-entry.addr);
                } else {
                    registry.registerAvailableMemory(entry.addr, entry.len);
                }
            }
            curAddr += mmap.entry_size;
        }
        
        __pasm__("addl %ebx, %eax", {"%eax": mmap, "%ebx": TagMMap:SIZEOF}, {"%eax": curAddr});
        __pasm__("addl %ebx, %eax", {"%eax": mmap, "%ebx": mmap.size}, {"%eax": endAddr});
        while (curAddr < endAddr) {
            MMapEntry entry = null;
            __pasm__("", {"%eax": curAddr}, {"%eax": entry});
            if (entry.addr_high) {
                // ignore memory > 4GB, 64 bit not yet available
            } else if (entry.type != MMapEntry:TYPE_AVAILABLE) {
                if (this._overflow(entry.addr, entry.len)) {
                    registry.registerReservedMemory(entry.addr, 0xffffffff-entry.addr);
                } else {
                    registry.registerReservedMemory(entry.addr, entry.len);
                }
            }
            curAddr += mmap.entry_size;
        }
        
        /* register kernel */
        registry.registerUsedMemory(address.load_addr, address.bss_end_addr - address.load_addr);
        /* register modules */
        TagModuleListElement cur = modules;
        while (cur) {
            TagModule module = cur.getModule();
            registry.registerUsedMemory(module.mod_start, module.mod_end - module.mod_start);
            cur = cur.getNext();
        }
        /* register mbi */
        int mbiLen = 0;
        __pasm__("movl (%eax), %eax", {"%eax": mbi}, {"%eax": mbiLen});
        registry.registerUsedMemory(mbi, mbiLen);
    }
    
    [] registerModules() {
        OStream out = this.rt().out();
        out.printPtr(address.load_addr).printChar(':').printPtr(address.bss_end_addr).printChar(' ').printCString(this.getCommandLine()).printNewline();
        TagModuleListElement cur = modules;
        while (cur) {
            TagModule module = cur.getModule();
            out.printPtr(module.mod_start).printChar(':').printPtr(module.mod_end).printChar(' ').printCString(this._getTagModuleCommandLine(module)).printNewline();
            cur = cur.getNext();
        }
    }
    
    [cstring] _getTagStringValue(TagString tag) {
        cstring string = "";
        __pasm__("addl %ebx, %eax", {"%eax": tag, "%ebx": TagString:SIZEOF}, {"%eax": string});
        return string;
    
    }
    
    [cstring] _getTagModuleCommandLine(TagModule tag) {
        cstring string = "";
        __pasm__("addl %ebx, %eax", {"%eax": tag, "%ebx": TagModule:SIZEOF}, {"%eax": string});
        return string;
    }
    
    [int] _overflow(int a, int b) {
        int diff = 0;
        __pasm__(<"
            movl 1, %ecx
            addl %ebx, %eax
            jb _bi__overflow_ret
            movl 0, %ecx
        _bi__overflow_ret:
        ">, {"%eax": a, "%ebx": b}, {"%ecx": diff});
        return diff;
    }
}
